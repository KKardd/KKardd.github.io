<hr />

<p>Nodejs에는 많은 ORM이 있다. 유래 깊은 Sequelize부터 Typescript가 등장한 시점에서 강타입의 ORM의 TypeORM, 그리고 최근 많은 호평을 받은 Prisma까지.</p>

<p>심지어 Prisma는 공식문서에서 Prisma가 다른 ORM보다 나은 이유를 설명하기까지 한다.(<a href="https://www.prisma.io/docs/orm/more/comparisons">링크</a>)</p>

<p>설명되어있는 이유들도 매력적이였지만, 성능에 관해서 얘기가 없었고 그래서 테스트해보기로 했다.</p>

<p>간단하게 테이블은 User(50,000 row), Company(3,774 row)이고 1:N 관계 지어져 있다.</p>

<p>추가로, id값들의 경우 인덱싱도 하였다.</p>

<h1 id="normal-query">Normal Query</h1>

<p>user테이블의 모든 값을 조회하는 쿼리이다.</p>

<h2 id="실행된-쿼리">실행된 쿼리</h2>

<h3 id="typeorm">TypeORM</h3>

<p>SELECT <code class="language-plaintext highlighter-rouge">Users</code>.<code class="language-plaintext highlighter-rouge">id</code> AS <code class="language-plaintext highlighter-rouge">Users_id</code>, <code class="language-plaintext highlighter-rouge">Users</code>.<code class="language-plaintext highlighter-rouge">name</code> AS <code class="language-plaintext highlighter-rouge">Users_name</code>, <code class="language-plaintext highlighter-rouge">Users</code>.<code class="language-plaintext highlighter-rouge">gender</code> AS <code class="language-plaintext highlighter-rouge">Users_gender</code>, <code class="language-plaintext highlighter-rouge">Users</code>.<code class="language-plaintext highlighter-rouge">created_date</code> AS <code class="language-plaintext highlighter-rouge">Users_created_date</code>, <code class="language-plaintext highlighter-rouge">Users</code>.<code class="language-plaintext highlighter-rouge">updated_date</code> AS <code class="language-plaintext highlighter-rouge">Users_updated_date</code>, <code class="language-plaintext highlighter-rouge">Users</code>.<code class="language-plaintext highlighter-rouge">company_id</code> AS <code class="language-plaintext highlighter-rouge">Users_company_id</code> FROM <code class="language-plaintext highlighter-rouge">users</code> <code class="language-plaintext highlighter-rouge">Users</code></p>

<h3 id="prisma">Prisma</h3>

<p>SELECT <code class="language-plaintext highlighter-rouge">DongAJul</code>.<code class="language-plaintext highlighter-rouge">users</code>.<code class="language-plaintext highlighter-rouge">id</code>, <code class="language-plaintext highlighter-rouge">DongAJul</code>.<code class="language-plaintext highlighter-rouge">users</code>.<code class="language-plaintext highlighter-rouge">name</code>, <code class="language-plaintext highlighter-rouge">DongAJul</code>.<code class="language-plaintext highlighter-rouge">users</code>.<code class="language-plaintext highlighter-rouge">gender</code>, <code class="language-plaintext highlighter-rouge">DongAJul</code>.<code class="language-plaintext highlighter-rouge">users</code>.<code class="language-plaintext highlighter-rouge">created_date</code>, <code class="language-plaintext highlighter-rouge">DongAJul</code>.<code class="language-plaintext highlighter-rouge">users</code>.<code class="language-plaintext highlighter-rouge">updated_date</code>, <code class="language-plaintext highlighter-rouge">DongAJul</code>.<code class="language-plaintext highlighter-rouge">users</code>.<code class="language-plaintext highlighter-rouge">company_id</code> FROM <code class="language-plaintext highlighter-rouge">DongAJul</code>.<code class="language-plaintext highlighter-rouge">users</code> WHERE 1=1</p>

<h2 id="성능-비교">성능 비교</h2>

<p>TypeORM 10 사용자 / 10회</p>

<p><img src="/assets/img/Study/Prisma%20VS%20TypeORM-0.jpg" alt="image.jpg" /></p>

<p>Prisma 10 사용자 / 10회</p>

<p><img src="/assets/img/Study/Prisma%20VS%20TypeORM-1.jpg" alt="image.jpg" /></p>

<h2 id="차이점">차이점</h2>

<ol>
  <li>Prisma는 데이터베이스 명을 꼭 명시해줬다.</li>
  <li>TypeORM은 AS를 통해 Users라는 객체를 만들고자 하는게 느껴졌다.</li>
  <li>Prisma는 Where 1=1 을 추가해주었다.
    <ol>
      <li>Where 1=1을 추가하는 이유가 궁금했었는데, 찾아보니 추가로 and 조건이 붙어야 할때, 편하게 조건을 사용하기 위함이라고 한다. 디테일이… 기가 막히다..</li>
      <li>where절이 이미 있었는지 판단하고 없을때는 where을, 있을때는 and 조건을 붙여야 하는게 메모리의 낭비를 초래할 수 있다고 판단한 거 같다.</li>
    </ol>
  </li>
</ol>

<hr />

<h1 id="left-join-query">Left Join Query</h1>

<h2 id="실행된-쿼리-1">실행된 쿼리</h2>

<h3 id="typeorm-1">TypeORM</h3>

<ol>
  <li>SELECT <code class="language-plaintext highlighter-rouge">Users</code>.<code class="language-plaintext highlighter-rouge">id</code> AS <code class="language-plaintext highlighter-rouge">Users_id</code>, <code class="language-plaintext highlighter-rouge">Users</code>.<code class="language-plaintext highlighter-rouge">name</code> AS <code class="language-plaintext highlighter-rouge">Users_name</code>, <code class="language-plaintext highlighter-rouge">Users</code>.<code class="language-plaintext highlighter-rouge">gender</code> AS <code class="language-plaintext highlighter-rouge">Users_gender</code>, <code class="language-plaintext highlighter-rouge">Users</code>.<code class="language-plaintext highlighter-rouge">created_date</code> AS <code class="language-plaintext highlighter-rouge">Users_created_date</code>, <code class="language-plaintext highlighter-rouge">Users</code>.<code class="language-plaintext highlighter-rouge">updated_date</code> AS <code class="language-plaintext highlighter-rouge">Users_updated_date</code>, <code class="language-plaintext highlighter-rouge">Users</code>.<code class="language-plaintext highlighter-rouge">company_id</code> AS <code class="language-plaintext highlighter-rouge">Users_company_id</code>, <code class="language-plaintext highlighter-rouge">Users__Users_company</code>.<code class="language-plaintext highlighter-rouge">id</code> AS <code class="language-plaintext highlighter-rouge">Users__Users_company_id</code>, <code class="language-plaintext highlighter-rouge">Users__Users_company</code>.<code class="language-plaintext highlighter-rouge">name</code> AS <code class="language-plaintext highlighter-rouge">Users__Users_company_name</code>, <code class="language-plaintext highlighter-rouge">Users__Users_company</code>.<code class="language-plaintext highlighter-rouge">address</code> AS <code class="language-plaintext highlighter-rouge">Users__Users_company_address</code>, <code class="language-plaintext highlighter-rouge">Users__Users_company</code>.<code class="language-plaintext highlighter-rouge">longitude</code> AS <code class="language-plaintext highlighter-rouge">Users__Users_company_longitude</code>, <code class="language-plaintext highlighter-rouge">Users__Users_company</code>.<code class="language-plaintext highlighter-rouge">latitude</code> AS <code class="language-plaintext highlighter-rouge">Users__Users_company_latitude</code>, <code class="language-plaintext highlighter-rouge">Users__Users_company</code>.<code class="language-plaintext highlighter-rouge">scale</code> AS <code class="language-plaintext highlighter-rouge">Users__Users_company_scale</code>, <code class="language-plaintext highlighter-rouge">Users__Users_company</code>.<code class="language-plaintext highlighter-rouge">big_job_kind_id</code> AS <code class="language-plaintext highlighter-rouge">Users__Users_company_big_job_kind_id</code>, <code class="language-plaintext highlighter-rouge">Users__Users_company</code>.<code class="language-plaintext highlighter-rouge">mid_job_kind_id</code> AS <code class="language-plaintext highlighter-rouge">Users__Users_company_mid_job_kind_id</code>, <code class="language-plaintext highlighter-rouge">Users__Users_company</code>.<code class="language-plaintext highlighter-rouge">small_job_kind_id</code> AS <code class="language-plaintext highlighter-rouge">Users__Users_company_small_job_kind_id</code> FROM <code class="language-plaintext highlighter-rouge">users</code> <code class="language-plaintext highlighter-rouge">Users</code> LEFT JOIN <code class="language-plaintext highlighter-rouge">company</code> <code class="language-plaintext highlighter-rouge">Users__Users_company</code> ON <code class="language-plaintext highlighter-rouge">Users__Users_company</code>.<code class="language-plaintext highlighter-rouge">id</code>=<code class="language-plaintext highlighter-rouge">Users</code>.<code class="language-plaintext highlighter-rouge">company_id</code></li>
</ol>

<h3 id="prisma-1">Prisma</h3>

<ol>
  <li>query SELECT <a href="http://dongajul.users.id/">DongAJul.users.id</a>, <a href="http://dongajul.users.name/">DongAJul.users.name</a>, DongAJul.users.gender, DongAJul.users.created_date, DongAJul.users.updated_date, DongAJul.users.company_id FROM DongAJul.users WHERE 1=1
→ companyId 받아오는 과정</li>
  <li>SELECT <a href="http://dongajul.company.id/">DongAJul.company.id</a>, <a href="http://dongajul.company.name/">DongAJul.company.name</a>, DongAJul.company.address, DongAJul.company.longitude, DongAJul.company.latitude, DongAJul.company.scale, DongAJul.company.big_job_kind_id, DongAJul.company.mid_job_kind_id, DongAJul.company.small_job_kind_id FROM DongAJul.company WHERE <a href="http://dongajul.company.id/">DongAJul.company.id</a> IN (?, ? …)
→ companyId 넣어서 돌리기</li>
</ol>

<h2 id="성능-비교-1">성능 비교</h2>

<h3 id="typeorm-2">TypeORM</h3>

<p>부하테스트 5사용자 / 5회</p>

<p><img src="/assets/img/Study/Prisma%20VS%20TypeORM-2.jpg" alt="image.jpg" /></p>

<p>스트레스테스트 10사용자 / 10회</p>

<p><img src="/assets/img/Study/Prisma%20VS%20TypeORM-3.jpg" alt="image.jpg" /></p>

<h3 id="prisma-2">Prisma</h3>

<p>부하테스트 5사용자 / 5회</p>

<p><img src="/assets/img/Study/Prisma%20VS%20TypeORM-4.jpg" alt="image.jpg" /></p>

<p>스트레스테스트 10사용자 / 10회</p>

<p><img src="/assets/img/Study/Prisma%20VS%20TypeORM-5.jpg" alt="image.jpg" /></p>

<h2 id="차이점-1">차이점</h2>

<p>굉장히 놀랄만한 수치의 차이를 보였다. 를 보였고,</p>

<ol>
  <li>TypeORM은 정직하게 LEFT JOIN을 사용한 반면 Prisma는 Join쿼리 없이 Where In을 이용한 두개의 쿼리문을 실행하였다.</li>
  <li>부하테스트에서도 약 33% 가량의 차이 발생(<strong>Prisma Win!</strong>)</li>
  <li>스트레스 테스트에서는 무려 45개의 조회를 더 버텨낸 뒤에 다운되어버렸다.(<strong>Again Prisma!</strong>)
물론, 되게 극단적인 예시를 들었다. 애초에 유저 50000명과 3774개의 회사가 모두 담긴 조회가 필요한 경우는 극히 드물다고 생각한다. 그렇지만 같은 ORM임에도 다른 쿼리를 실행시킨다는 점, 그리고 큰 성능 차이가 일어났다는 점이 충격적으로 느껴졌다.</li>
</ol>

<p>여기서 멈추면 안된다. 왜 Where In절이 Left Join보다 월등히 성능이 높았는지가 궁금해져 찾아볼 것이고, 아마 다음 글의 내용이 되지않을까 싶다.</p>
